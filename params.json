{"name":"rndr.me","tagline":"an HTTP server that uses PhantomJS to render HTML","body":"rndr.me\r\n=======\r\n\r\n[![Build Status](https://travis-ci.org/jed/rndr.me.png?branch=master)](https://travis-ci.org/jed/rndr.me)\r\n\r\nrndr.me is a tiny http server that eats urls and poops html. It has only one dependency, [PhantomJS](http://phantomjs.org), which it uses evaluate each incoming url in a headless browser window, and output the html of the resulting DOM.\r\n\r\nHaving an easy, framework-agnostic way to create html snapshots helps solve two problems in single-page JavaScript app deployment:\r\n\r\n1. Single-page apps suffer from poor crawlability, because Google/Bing are less likely to discover content rendered on the client. In this case, use rndr.me to render the `_escape_fragment_` urls that [these crawlers want](https://developers.google.com/webmasters/ajax-crawling/), by [redirecting](https://developers.google.com/webmasters/ajax-crawling/docs/faq#redirects) from your backend.\r\n\r\n2. Single-page apps suffer from slow startup times, due to multiple round trips between the app and API. In this case, you can use rndr.me to pre-render hot pages, so that they can be inlined as HTML to improve perceived performance.\r\n\r\nOf course, this is just one approach for folks looking for way to improve SEO and performance when rendering single-page apps. If you're using Backbone.js and want a more tightly coupled solution, check out @airbnb's [rendr](https://github.com/airbnb/rendr). If you're looking for something a bit higher-level that'll run a cluster for you, check out @bfirsh's [otter](https://github.com/bfirsh/otter).\r\n\r\nInstallation\r\n------------\r\n\r\n1. [Install PhantomJS](http://phantomjs.org/download.html).\r\n2. Download [server.js](https://github.com/jed/rndr.me/blob/master/server.js) from this repo.\r\n\r\nSample setup\r\n------------\r\n\r\nIn this [example shell script](https://github.com/jed/rndr.me/blob/master/test.sh), we:\r\n\r\n- create a simple JavaScript app,\r\n- serve it on port 8000,\r\n- run rndr.me on port 8001, and\r\n- verify the app html as rendered by rndr.me.\r\n\r\n```bash\r\n#!/bin/sh\r\n\r\n# Create and save a simple JavaScript app\r\necho \"<script>document.write(location)</script>\" > ./index.html\r\n\r\n# Spin up a server to serve it\r\npython -m SimpleHTTPServer 8000 &\r\nAPP_PID=$!\r\n\r\n# Spin up the rndr.me server, wait until ready\r\nphantomjs ./server.js &\r\nrndrme_PID=$!\r\nsleep 1\r\n\r\n# Pick an app URL to be rendered\r\nURL='http://127.0.0.1:8000/#!/TESTING'\r\n\r\n# Get the results rendered by the rndr.me server\r\nHTML=`curl 127.0.0.1:8001 -s -G --data-urlencode href=$URL`\r\n\r\n# Check whether the rendered file contains the random URL\r\necho $HTML | grep -q $URL\r\nNOT_FOUND=$?\r\n\r\n# Spin down, clean up, and exit\r\nrm ./index.html\r\nkill -9 $rndrme_PID\r\nkill -9 $APP_PID\r\nexit $NOT_FOUND\r\n```\r\n\r\nQuickstart on Heroku\r\n--------------------\r\n\r\nBecause rndr.me depends only on PhantomJS, it's easy to set up and run yourself. This [example shell script](https://github.com/jed/rndr.me/blob/master/heroku.sh) shows you everything you need to start your own instance running on [Heroku](https://www.heroku.com).\r\n\r\n```bash\r\n# Create a place for your renderer to live\r\nmkdir my_renderer\r\ncd my_renderer\r\n\r\n# Create a git repo with rndr.me and a Procfile\r\ngit init\r\ngit submodule add git://github.com/jed/rndr.me.git\r\necho \"web: phantomjs rndr/server.js\" > Procfile\r\n\r\n# Create a new Heroku app with the PhantomJS buildpack\r\nheroku apps:create\r\nheroku config:add BUILDPACK_URL=http://github.com/stomita/heroku-buildpack-phantomjs.git\r\n\r\n# Push your code\r\ngit add .\r\ngit commit -m \"first commit\"\r\ngit push heroku master\r\n\r\n# Scale your app\r\nheroku ps:scale web=1\r\n```\r\n\r\nAPI\r\n---\r\n\r\nTo spin up the server, run the following from the command line:\r\n\r\n    phantomjs ./server.js <config-path>\r\n\r\nNote that `config-path` is optional, and if omitted will default to the provided [config.js](https://github.com/jed/rndr.me/blob/master/config.js) file.\r\n\r\nThe server exposes a single root endpoint at `/`. It returns generated html, based on the following parameters:\r\n\r\n- `href`: The url to be rendered. This is required, and must be fully qualified.\r\n- `max_time`: The maximum number of milliseconds until render. Any windows not already rendered by the `ready_event` will be rendered once this elapses. This is optional, and `30000` by default (30 seconds).\r\n- `max_bytes`: The maximum number of incoming bytes. Any windows that load more than this value will return an error without rendering. This is optional, and `1048576` by default (1 MiB).\r\n- `load_images`: This can be specified to any value to load document images. This is optional, and omitted by default.\r\n- `ready_event`: This is the name of the `window` event that triggers render. This is optional, and `load` by default. To specify when rendering occurs, such as when the DOM is not ready to be rendered until after `window.onload`, trigger a DOM event manually, such as follows (using jQuery in this case):\r\n\r\n```javascript\r\njQuery.getJSON(\"http://api.myapp.com\", function(data) {\r\n  myCustomRenderingCallback(data)\r\n\r\n  var readyEvent = document.createEvent(\"Event\")\r\n  readyEvent.initEvent(\"renderReady\", true, true)\r\n  window.dispatchEvent(readyEvent)\r\n})\r\n```\r\n\r\nExamples\r\n--------\r\n\r\nThe following examples assume a single-page app running in production at `http:/myapp.com` and rndr.me running as follows:\r\n\r\n```bash\r\nphantomjs ./server.js 8080\r\n```\r\n\r\nLet's render the app with default settings:\r\n\r\n```bash\r\ncurl localhost:8080 -G \\\r\n  --data-urlencode 'href=http://myapp.com/#!home'\r\n```\r\n\r\nNow let's cap the maximum rendering time at 10 seconds:\r\n\r\n```bash\r\ncurl localhost:8080 -G \\\r\n  --data-urlencode 'href=http://myapp.com/#!home'\r\n  -d max_time=10000\r\n```\r\n\r\nWe can also cap the maximum incoming bytes at 100KiB:\r\n\r\n```bash\r\ncurl localhost:8080 -G \\\r\n  --data-urlencode 'href=http://myapp.com/#!home'\r\n  -d max_time=10000\r\n  -d max_bytes=102400\r\n```\r\n\r\nNow let's allow images to load, raising the maximum incoming bytes to 500KiB:\r\n\r\n```bash\r\ncurl localhost:8080 -G \\\r\n  --data-urlencode 'href=http://myapp.com/#!home'\r\n  -d max_time=10000\r\n  -d max_bytes=512000\r\n  -d load_images\r\n```\r\n\r\nNow let's use the custom rendering event `render_ready`, triggered on the window of the DOM, using the default fallback maximum time:\r\n\r\n```bash\r\ncurl localhost:8080 -G \\\r\n  --data-urlencode 'href=http://myapp.com/#!home'\r\n  -d max_bytes=512000\r\n  -d load_images\r\n  -d ready_event=render_ready\r\n```\r\n\r\nLICENSE\r\n-------\r\n\r\n(The MIT License)\r\n\r\nCopyright (c) 2013 Jed Schmidt &lt;where@jed.is&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n'Software'), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}